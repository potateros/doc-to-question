File: question-generator/public/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

File: question-generator/src/App.css
.app {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}

h1 {
  text-align: center;
  color: #333;
}

.upload-section {
  margin-bottom: 20px;
}

.btn {
  background-color: #4CAF50;
  border: none;
  color: white;
  padding: 10px 20px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
}

.btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.error {
  color: red;
  font-weight: bold;
}

.loading {
  text-align: center;
}

.spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

.questions-section {
  margin-top: 20px;
}

.submit-btn {
  display: block;
  margin: 20px auto;
  background-color: #3498db;
}

File: question-generator/src/App.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import Question from './components/Question';
import History from './components/History';
import './App.css';

const App = () => {
  const [file, setFile] = useState(null);
  const [questions, setQuestions] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [submitted, setSubmitted] = useState(false);
  const [history, setHistory] = useState([]);

  useEffect(() => {
    const savedHistory = localStorage.getItem('questionHistory');
    if (savedHistory) {
      setHistory(JSON.parse(savedHistory));
    }
  }, []);

  const saveToHistory = (newQuestions) => {
    const updatedHistory = [
      { id: Date.now(), questions: newQuestions },
      ...history,
    ].slice(0, 5);
    setHistory(updatedHistory);
    localStorage.setItem('questionHistory', JSON.stringify(updatedHistory));
  };

  const handleFileChange = (e) => {
    setFile(e.target.files[0]);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!file) {
      setError('Please select a file first');
      return;
    }

    setIsLoading(true);
    setError(null);

    const formData = new FormData();
    formData.append('pdf', file);

    try {
      const response = await axios.post('http://localhost:3001/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });

      if (response.data && response.data.questions) {
        const newQuestions = response.data.questions.map(q => ({
          ...q,
          userAnswer: getInitialUserAnswer(q.type),
          isCorrect: null
        }));
        setQuestions(newQuestions);
        saveToHistory(newQuestions);
      } else {
        throw new Error('Invalid response format');
      }
    } catch (error) {
      console.error('Error uploading file:', error);
      setError(error.response?.data?.message || error.message || 'An unexpected error occurred. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const getInitialUserAnswer = (type) => {
    switch (type) {
      case 'checklist':
        return [];
      case 'multiple-choice':
      case 'true-false':
      case 'text':
        return '';
      default:
        return null;
    }
  };

  const handleAnswer = (index, answer) => {
    setQuestions((prev) => {
      const newQuestions = [...prev];
      newQuestions[index].userAnswer = answer;
      return newQuestions;
    });
  };

  const handleSubmitAnswers = () => {
    setSubmitted(true);
    setQuestions((prev) =>
      prev.map((q) => ({
        ...q,
        isCorrect: Array.isArray(q.correctAnswer)
          ? JSON.stringify(q.userAnswer.sort()) === JSON.stringify(q.correctAnswer.sort())
          : q.userAnswer === q.correctAnswer,
      }))
    );
  };

  const handleResetAnswers = () => {
    setSubmitted(false);
    setQuestions((prev) =>
      prev.map((q) => ({ ...q, userAnswer: getInitialUserAnswer(q.type), isCorrect: null }))
    );
  };

  const handleLoadHistory = (historicalQuestions) => {
    setQuestions(historicalQuestions);
    setSubmitted(false);
  };

  return (
    <div className="app">
      <h1>PDF to Question Generator</h1>
      <div className="upload-section">
        <form onSubmit={handleSubmit}>
          <input type="file" accept="application/pdf" onChange={handleFileChange} />
          <button type="submit" disabled={isLoading} className="btn">
            {isLoading ? 'Processing...' : 'Upload and Generate Questions'}
          </button>
        </form>
      </div>

      {error && <p className="error">{error}</p>}

      {isLoading && (
        <div className="loading">
          <p>Processing PDF and generating questions...</p>
          <div className="spinner"></div>
        </div>
      )}

      <History history={history} onLoadHistory={handleLoadHistory} />

      <div className="questions-section">
        {questions.map((q, index) => (
          <Question
            key={index}
            {...q}
            onAnswer={(answer) => handleAnswer(index, answer)}
            submitted={submitted}
          />
        ))}
      </div>

      {questions.length > 0 && (
        <button onClick={submitted ? handleResetAnswers : handleSubmitAnswers} className="btn submit-btn">
          {submitted ? 'Reset Answers' : 'Submit Answers'}
        </button>
      )}
    </div>
  );
};

export default App;

File: question-generator/src/App.test.js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

File: question-generator/src/components/Checklist.jsx
import React from 'react';

const Checklist = ({ question, options, onAnswer, userAnswer, submitted }) => {
  const handleChange = (e) => {
    const value = e.target.value;
    const updatedAnswer = Array.isArray(userAnswer) ? [...userAnswer] : [];

    if (updatedAnswer.includes(value)) {
      // Remove the option if it's already selected
      onAnswer(updatedAnswer.filter((item) => item !== value));
    } else {
      // Add the option if it's not already selected
      onAnswer([...updatedAnswer, value]);
    }
  };

  return (
    <>
      <h3>{question}</h3>
      <div className="options">
        {options.map((option, index) => (
          <div key={index} className="option">
            <input
              type="checkbox"
              id={`checklist-${question}-${index}`}
              value={option}
              onChange={handleChange}
              checked={Array.isArray(userAnswer) && userAnswer.includes(option)}
              disabled={submitted}
            />
            <label htmlFor={`checklist-${question}-${index}`}>{option}</label>
          </div>
        ))}
      </div>
    </>
  );
};

export default Checklist;

File: question-generator/src/components/History.css
.history {
  margin-bottom: 20px;
  padding: 10px;
  background-color: #f0f0f0;
  border-radius: 5px;
}

.history h2 {
  margin-top: 0;
  font-size: 1.2em;
}

.history ul {
  list-style-type: none;
  padding: 0;
}

.history li {
  cursor: pointer;
  padding: 5px 0;
  transition: background-color 0.2s;
}

.history li:hover {
  background-color: #e0e0e0;
}

File: question-generator/src/components/History.jsx
import React from 'react';
import './History.css';

const History = ({ history, onLoadHistory }) => {
  if (history.length === 0) {
    return null;
  }

  return (
    <div className="history">
      <h2>Recent Question Sets</h2>
      <ul>
        {history.map((item) => (
          <li key={item.id} onClick={() => onLoadHistory(item.questions)}>
            {new Date(item.id).toLocaleString()} - {item.questions.length}{' '}
            questions
          </li>
        ))}
      </ul>
    </div>
  );
};

export default History;

File: question-generator/src/components/MultipleChoice.jsx
import React from 'react';

const MultipleChoice = ({
  question,
  options,
  onAnswer,
  userAnswer,
  submitted,
}) => {
  // Generate a unique identifier for this question
  const questionId = React.useMemo(
    () => `mc_${Math.random().toString(36).substr(2, 9)}`,
    []
  );

  const handleChange = (e) => {
    onAnswer(e.target.value);
  };

  return (
    <>
      <h3>{question}</h3>
      <div className="options">
        {options.map((option, index) => (
          <div key={index} className="option">
            <input
              type="radio"
              id={`${questionId}-${index}`}
              name={questionId}
              value={option}
              onChange={handleChange}
              checked={userAnswer === option}
              disabled={submitted}
            />
            <label htmlFor={`${questionId}-${index}`}>{option}</label>
          </div>
        ))}
      </div>
    </>
  );
};

export default MultipleChoice;

File: question-generator/src/components/Question.css
.question {
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border: 2px solid transparent;
}

.question.correct {
  border-color: #28a745;
  background-color: #d4edda;
}

.question.incorrect {
  border-color: #dc3545;
  background-color: #f8d7da;
}

.feedback {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #ddd;
}

.correct-text {
  color: #28a745;
  font-weight: bold;
}

.incorrect-text {
  color: #dc3545;
  font-weight: bold;
}

File: question-generator/src/components/Question.jsx
// Question.jsx
import React from 'react';
import Checklist from './Checklist';
import MultipleChoice from './MultipleChoice';
import TextResponse from './TextResponse';
import TrueFalse from './TrueFalse';
// import UnknownType from './UnknownType';
import './Question.css';

const Question = (props) => {
  const {
    type,
    question,
    options,
    answer,
    answers,
    onAnswer,
    userAnswer,
    isCorrect,
    submitted,
  } = props;

  const correctAnswer = answers || answer;

  const renderQuestionType = () => {
    const commonProps = { question, onAnswer, userAnswer, submitted };
    switch (type) {
      case 'checklist':
        return <Checklist {...commonProps} options={options} />;
      case 'multiple-choice':
        return <MultipleChoice {...commonProps} options={options} />;
      case 'text':
        return <TextResponse {...commonProps} />;
      case 'true-false':
        return <TrueFalse {...commonProps} />;
      default:
        return <TextResponse {...commonProps} />;
    }
  };

  const renderCorrectAnswer = () => {
    if (correctAnswer == null) {
      return 'Not available';
    }
    if (Array.isArray(correctAnswer)) {
      return correctAnswer.join(', ');
    }
    if (typeof correctAnswer === 'boolean') {
      return correctAnswer ? 'True' : 'False';
    }
    return correctAnswer.toString();
  };

  const renderUserAnswer = () => {
    if (userAnswer == null) {
      return 'No answer provided';
    }
    if (Array.isArray(userAnswer)) {
      return userAnswer.join(', ');
    }
    if (typeof userAnswer === 'boolean') {
      return userAnswer ? 'True' : 'False';
    }
    return userAnswer.toString();
  };

  return (
    <div
      className={`question ${
        submitted ? (isCorrect ? 'correct' : 'incorrect') : ''
      }`}
    >
      {renderQuestionType()}
      {submitted && (
        <div className="feedback">
          <p className={isCorrect ? 'correct-text' : 'incorrect-text'}>
            {isCorrect ? 'Correct!' : 'Incorrect'}
          </p>
          <p>
            <strong>Correct answer:</strong> {renderCorrectAnswer()}
          </p>
          {!isCorrect && (
            <p>
              <strong>Your answer:</strong> {renderUserAnswer()}
            </p>
          )}
        </div>
      )}
    </div>
  );
};

export default Question;

File: question-generator/src/components/TextResponse.jsx
import React from 'react';

const TextResponse = ({
  question,
  onAnswer,
  userAnswer,
  submitted,
  isCorrect,
}) => {
  const handleChange = (e) => {
    onAnswer(e.target.value);
  };

  return (
    <>
      <h3>{question}</h3>
      <div
        className={`text-response ${submitted && isCorrect ? 'correct' : ''}`}
      >
        <textarea
          onChange={handleChange}
          placeholder="Type your answer here..."
          rows="4"
          className="text-area"
          value={userAnswer || ''}
          disabled={submitted}
        />
      </div>
    </>
  );
};

export default TextResponse;

File: question-generator/src/components/TrueFalse.jsx
import React from 'react';

const TrueFalse = ({ question, onAnswer, userAnswer, submitted }) => {
  // Generate a unique identifier for this question
  const questionId = React.useMemo(
    () => `tf_${Math.random().toString(36).substr(2, 9)}`,
    []
  );

  const handleChange = (e) => {
    onAnswer(e.target.value === 'true');
  };

  return (
    <>
      <h3>{question}</h3>
      <div className="options">
        <div className="option">
          <input
            type="radio"
            id={`${questionId}-true`}
            name={questionId}
            value="true"
            onChange={handleChange}
            checked={userAnswer === true}
            disabled={submitted}
          />
          <label htmlFor={`${questionId}-true`}>True</label>
        </div>
        <div className="option">
          <input
            type="radio"
            id={`${questionId}-false`}
            name={questionId}
            value="false"
            onChange={handleChange}
            checked={userAnswer === false}
            disabled={submitted}
          />
          <label htmlFor={`${questionId}-false`}>False</label>
        </div>
      </div>
    </>
  );
};

export default TrueFalse;

File: question-generator/src/index.css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

File: question-generator/src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

File: server.js
const express = require('express');
const multer = require('multer');
const pdfParse = require('pdf-parse');
const OpenAI = require('openai');
const fs = require('fs');
const path = require('path');
const cors = require('cors');
require('dotenv').config();

const app = express();
const upload = multer({ dest: 'uploads/' });

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

app.use(cors({
  origin: 'http://localhost:3000' // Allow requests from your frontend
}));

app.use(express.json());

const MAX_TOKENS = 4096; // Maximum tokens OpenAI API can handle, adjust as needed

// Summarize text to reduce token count
const summarizeText = async (text) => {
  console.log('Summarizing text...')
  try {
    const response = await openai.chat.completions.create({
      messages: [{ role: "user", content: `Summarize the following text to reduce it to essential points:\n\n${text}` }],
      model: "gpt-4o-mini",
    });
    return response.choices[0].message.content;
  } catch (error) {
    console.error('Error summarizing text:', error);
    return text; // Return original text if summarization fails
  }
};

// Route to upload PDF and generate questions
app.post('/upload', upload.single('pdf'), async (req, res) => {
  const pdfPath = path.join(__dirname, req.file.path);

  try {
    const dataBuffer = fs.readFileSync(pdfPath);
    const pdfData = await pdfParse(dataBuffer);
    const fullText = pdfData.text;

    // Split text into chunks to fit within token limits
    const textChunks = [];
    let chunk = '';

    fullText.split(/\n\s*\n/).forEach((paragraph) => {
      if (chunk.length + paragraph.length > MAX_TOKENS * 4) { // Adjust to prevent exceeding token limit
        textChunks.push(chunk);
        chunk = '';
      }
      chunk += paragraph + '\n\n';
    });

    if (chunk) textChunks.push(chunk); // Add the last chunk

    // Summarize each chunk
    const summarizedChunks = await Promise.all(
      textChunks.map(async (text) => await summarizeText(text))
    );

    const summarizedText = summarizedChunks.join('\n\n');

    // Send the summarized text to OpenAI API to generate questions
    const exampleJson = `
      [
        {
          "type": "true-false",
          "question": "The Transformer model requires less training time compared to RNN-based models.",
          "answer": true
        },
        {
          "type": "checklist",
          "question": "Select the benefits of using self-attention in sequence transduction tasks.",
          "options": ["Parallelization", "Reduced Path Length", "Sequential Computation", "Memory Efficiency"],
          "answers": ["Parallelization", "Reduced Path Length"]
        },
        {
          "type": "text",
          "question": "Explain how positional encoding is used in the Transformer model.",
          "answer": "Positional encoding is used to inject information about the relative or absolute position of tokens in a sequence since the Transformer model lacks recurrence and convolution."
        },
        {
          "type": "multiple-choice",
          "question": "What does the scaling factor 1/√dk address in the scaled dot-product attention?",
          "options": ["Gradient Vanishing", "Gradient Exploding", "Computational Complexity", "Softmax Saturation"],
          "answer": "Softmax Saturation"
        },
      ]`

    // Send the text to OpenAI API to generate questions
    const prompt = `Based on the following text, generate a JSON structure with various types of questions: multiple-choice, true/false, checklist, and text responses. Here is an example of the JSON structure you should return: ${exampleJson}. Give me 10 questions, with any combination of the 4 types of questions, Here is the text:\n\n${summarizedText}`;

    const response = await openai.chat.completions.create({
      messages: [{ role: "user", content: prompt }],
      model: "gpt-4o-mini",
    });

    const rawOutput = response.choices[0].message.content;
    const questionJSON = rawOutput.match(/```json([\s\S]*?)```/)[1].trim();
    const questions = JSON.parse(questionJSON);

    console.log(`questions: ${questions}`)

    // Return the questions to the frontend
    res.json({ questions });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to process PDF' });
  } finally {
    // Cleanup
    fs.unlinkSync(pdfPath);
  }
});

app.listen(3001, () => {
  console.log('Server running on http://localhost:3001');
});

